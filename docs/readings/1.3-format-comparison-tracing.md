# Lesson 1.3: Format Comparison & Model Tracing

## Four Components of an ML Model

Every complete model needs:

| Component | Purpose | Example |
|-----------|---------|---------|
| **Weights** | Learned parameters | `model.safetensors` |
| **Tokenizer** | Text ↔ tokens | `tokenizer.json` |
| **Config** | Architecture | `config.json` |
| **Metadata** | Model card, license | `README.md` |

## Format Packaging Comparison

| Format | Weights | Tokenizer | Config | Metadata |
|--------|---------|-----------|--------|----------|
| GGUF | Embedded | Embedded | Embedded | Embedded |
| SafeTensors | Separate | Separate | Separate | Separate |
| APR | Embedded | Embedded | JSON header | JSON header |

## Why Trace Models?

### Problem 1: NaN Propagation
```
Layer 1:  0.001% NaN  ← Problem starts here
Layer 12: 15% NaN
Layer 24: 100% NaN    ← Model is dead
```

Layer tracing catches issues at the source.

### Problem 2: Attention Spikes
- Abnormal attention patterns indicate issues
- Tracing reveals which heads are problematic

### Problem 3: Memory Leaks
- Track tensor allocations per layer
- Identify accumulating buffers

### Problem 4: Latency Bottlenecks
- Per-layer timing
- Find slow operations

## Tracing in Production

```rust
// Enable layer tracing
let model = Model::load("model.apr")?
    .with_tracing(true);

// Run inference
let output = model.forward(&input)?;

// Get trace
let trace = model.get_trace();
for layer in trace.layers() {
    println!("{}: {:?}", layer.name, layer.stats);
}
```

## Key Takeaways

- Models need 4 components: weights, tokenizer, config, metadata
- Formats differ in how they package components
- Tracing catches NaN propagation early
- Layer-level observability is essential for production
