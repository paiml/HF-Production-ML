{"text":" Let's take a look at this make file that shows the key components of the demo, the benchmark, the diagnosis, the JSON, the SRT, the profile. What's nice about this style is that it tells me exactly what I'm going to do. I'm going to benchmark things, so I'm going to run the command whisper APR CLI benchmark. I'm going to diagnose, but it controls the abstraction. So this is a great way to top of a large language model to make it more simple to deal with is you wrap it and rust, then you put your demo inside of a make file and this makes things much more simple to use. So first up here, let's try the make benchmark. In this case, we'll do make benchmark. And this shows us that it's going to use the tiny model and it's going to use the SIMD back end and it's going to do three iterations and then show us what to put this is critical as well. Not just getting the correctness there, which is a lot of work to make sure your model works, but also the performance. In this case, we can see that the RTF shows us that it's three times faster than real time. So if I was going to transcribe a whole series of items, it's if at the runtime is a minute, it would be able to transcribe it in a third of a minute or 20 seconds or so. Now let's go ahead and take a look at make diagnose and what this does is it shows us the whole self diagnostics. So the tokens, the also the language base, the known issues as well. These are all things that you could add inside of your demo. What if we want to look at the JSON output? This would be make JSON. In this case, this would show us that we have the text, we have the language and the segments. So if I'm building complex automation pipeline, I could output Jason and have another tool go through and read this. So the traditional software engineering best practices haven't gone away when you're using large language models or even these smaller reduced ones that work on the CPU. In fact, they're even more important because you need them to control the complexity of working with models and also wrapping them into traditional tools. What's nice about demo is that we also can put the model inside of the binary as well as other types of APR projects. And by combining the binary inside with the model, you can also have a much more deterministic way to build demos to diagnose the things you're working with.","segments":[]}