{"text":" What if you could run ML inference in your browser with no server, no Python and sub-milusic and latency? That's really what we get with APR plus web assembly delivery. If we look at the APR format, this is called the Apprandeir Portable Representation. And the idea here is that it was designed by default to use web assembly, but also can scale out to CUDA. If you look at the header, one cache line on modern CPUs. The metadata is JSON, so it's human readable, easy to debug. And also if you look at the tensor data section, this is where we have the magic. Every tensor starts on that 64 byte boundary. When WebAssembly loads, they're already aligned for this vector operation. Now, if we look at WebAssembly, why do we really care about it for web applications? In the case of Rust, you can compile directly to WebAssembly. JavaScript or you can put a small shim and even programmatically create that JavaScript. The APR then loads inside and you can validate the checks on them and all this can happen in milliseconds. The other thing that's interesting is that because what assembly has linear memory, you can also load APR bytes directly into the memory. So there's no parsing, no copying, and then you've got the whole thing loaded into memory. So for small files, this really becomes very can convert from GZUF or save tensor and so you also have the ability to leverage existing models. In terms of browser runtime, it's not just a theoretical demo, you can go to interactive.pyaml.com. You can take a look at some of these demos, they can work on an airplane, you don't need API keys or rate limits because it's just a file that works inside of your browser. This is really the power is that they work directly inside of your browser. Now let's go ahead and take a look next at how we can actually build this into a demo and also take a look at all the different things you can do with APR. A good place to take a look at how you can build very tiny models that run in WebAssembly is to go to interactive.paiml.com. You can see there's lots of examples here, but we're going to go to powerful about this is this is a very tiny dot apiore model and you can see here that we get instant feedback, right? We get the ability to immediately figure out exactly what it is that I want to auto complete and it's happening inside of a browser without any interaction to the outside world. And what's really nice about this is that I can train this locally and I don't need any special setup. I can use rust as can publish it either to an external component or also I can publish it local and run it offline. So by having web assembly based systems that talk to the EPR format, we really can leverage the power of this upcoming revolution in small language models.","segments":[]}