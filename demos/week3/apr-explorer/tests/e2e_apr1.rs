//! End-to-end tests for real APR1 files
//!
//! These tests load actual APR1 files generated by the Python script
//! to verify the Rust parser works with real data.

use apr_explorer::{parse_apr, AprExplorerDriver};
use std::fs;

/// Test loading the sample MLP model
#[test]
fn test_load_sample_mlp() {
    let path = "www/sample-mlp.apr";
    if !std::path::Path::new(path).exists() {
        eprintln!(
            "Skipping test: {} not found (run generate_sample.py first)",
            path
        );
        return;
    }

    let bytes = fs::read(path).expect("Failed to read sample-mlp.apr");
    let model = parse_apr(&bytes).expect("Failed to parse sample-mlp.apr");

    // Verify header
    assert_eq!(model.header.magic, "APR1");
    assert!(!model.header.compressed);
    assert_eq!(model.header.n_tensors, 4);

    // Verify metadata
    assert_eq!(model.metadata.get("model_type").unwrap(), "mlp");
    assert_eq!(model.metadata.get("architecture").unwrap(), "feedforward");
    assert_eq!(model.metadata.get("hidden_size").unwrap(), 128);
    assert_eq!(model.metadata.get("num_layers").unwrap(), 2);

    // Verify tensors
    assert_eq!(model.tensors.len(), 4);

    // layer.0.weight
    assert_eq!(model.tensors[0].name, "layer.0.weight");
    assert_eq!(model.tensors[0].dtype, "F32");
    assert_eq!(model.tensors[0].shape, vec![128, 64]);
    assert_eq!(model.tensors[0].size, 32768);

    // layer.0.bias
    assert_eq!(model.tensors[1].name, "layer.0.bias");
    assert_eq!(model.tensors[1].shape, vec![128]);
    assert_eq!(model.tensors[1].size, 512);

    // layer.1.weight
    assert_eq!(model.tensors[2].name, "layer.1.weight");
    assert_eq!(model.tensors[2].shape, vec![10, 128]);

    // layer.1.bias
    assert_eq!(model.tensors[3].name, "layer.1.bias");
    assert_eq!(model.tensors[3].shape, vec![10]);
}

/// Test loading the sample transformer model
#[test]
fn test_load_sample_transformer() {
    let path = "www/sample-transformer.apr";
    if !std::path::Path::new(path).exists() {
        eprintln!(
            "Skipping test: {} not found (run generate_sample.py first)",
            path
        );
        return;
    }

    let bytes = fs::read(path).expect("Failed to read sample-transformer.apr");
    let model = parse_apr(&bytes).expect("Failed to parse sample-transformer.apr");

    // Verify header
    assert_eq!(model.header.magic, "APR1");
    assert!(!model.header.compressed);
    assert_eq!(model.header.n_tensors, 7);

    // Verify metadata
    assert_eq!(model.metadata.get("model_type").unwrap(), "transformer");
    assert_eq!(model.metadata.get("architecture").unwrap(), "encoder-only");
    assert_eq!(model.metadata.get("hidden_size").unwrap(), 256);
    assert_eq!(model.metadata.get("num_attention_heads").unwrap(), 4);
    assert_eq!(model.metadata.get("vocab_size").unwrap(), 1000);

    // Verify tensors
    assert_eq!(model.tensors.len(), 7);

    // embed.weight
    assert_eq!(model.tensors[0].name, "embed.weight");
    assert_eq!(model.tensors[0].shape, vec![1000, 256]);

    // Check attention weights exist
    let tensor_names: Vec<_> = model.tensors.iter().map(|t| t.name.as_str()).collect();
    assert!(tensor_names.contains(&"layers.0.attn.q.weight"));
    assert!(tensor_names.contains(&"layers.0.attn.k.weight"));
    assert!(tensor_names.contains(&"layers.0.attn.v.weight"));
    assert!(tensor_names.contains(&"layers.0.attn.o.weight"));
    assert!(tensor_names.contains(&"layers.0.ffn.up.weight"));
    assert!(tensor_names.contains(&"layers.0.ffn.down.weight"));
}

/// Test using the driver with real files
#[test]
fn test_driver_with_real_file() {
    let path = "www/sample-mlp.apr";
    if !std::path::Path::new(path).exists() {
        eprintln!("Skipping test: {} not found", path);
        return;
    }

    let bytes = fs::read(path).expect("Failed to read file");

    let mut driver = AprExplorerDriver::new();
    let result = driver.load_bytes(&bytes);
    assert!(result.is_ok());

    let model = driver.model().unwrap();
    assert_eq!(model.tensors.len(), 4);

    // Check DOM was updated
    assert!(driver.status_text().unwrap().contains("Loaded"));
    assert_eq!(driver.tensor_count_text(), Some("4"));
}

/// Test file drop simulation with real file
#[test]
fn test_drop_file_real() {
    let path = "www/sample-mlp.apr";
    if !std::path::Path::new(path).exists() {
        eprintln!("Skipping test: {} not found", path);
        return;
    }

    let bytes = fs::read(path).expect("Failed to read file");

    let mut driver = AprExplorerDriver::new();
    driver.drop_file("sample-mlp.apr", &bytes);

    assert!(driver.model().is_some());
    assert!(driver.error().is_none());
}

/// Test clear operation after loading real file
#[test]
fn test_clear_after_real_file() {
    let path = "www/sample-mlp.apr";
    if !std::path::Path::new(path).exists() {
        eprintln!("Skipping test: {} not found", path);
        return;
    }

    let bytes = fs::read(path).expect("Failed to read file");

    let mut driver = AprExplorerDriver::new();
    driver.load_bytes(&bytes).unwrap();

    assert!(driver.model().is_some());

    driver.clear();

    assert!(driver.model().is_none());
    assert_eq!(driver.status_text(), Some("Ready"));
}

/// Test that invalid files fail appropriately
#[test]
fn test_invalid_file_error() {
    let mut driver = AprExplorerDriver::new();

    // Try loading a non-APR file
    let invalid_bytes = b"This is not an APR file";
    let result = driver.load_bytes(invalid_bytes);

    assert!(result.is_err());
    assert!(driver.error().is_some());
    assert!(driver.status_text().unwrap().contains("Error"));
}

/// Test loading file that's too small
#[test]
fn test_file_too_small() {
    let result = parse_apr(&[0u8; 4]);
    assert!(result.is_err());
}

/// Test file with invalid magic
#[test]
fn test_invalid_magic() {
    let mut bytes = vec![0u8; 100];
    bytes[0..4].copy_from_slice(b"XXXX"); // Invalid magic
    let result = parse_apr(&bytes);
    assert!(result.is_err());
}
